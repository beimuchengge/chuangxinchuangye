import random


def tianchong(plaintext, plainlen):  # 将明文按格式要求填充为长度为512倍数的二进制串
    k = (959 - (plainlen % 512)) % 512
    m = (((plaintext << 1) + 1) << (k + 64)) + 24
    return m


def P0(X):
    return X ^ (X << 9 & 0xffffffff | X >> 23) ^ (X << 17 & 0xffffffff | X >> 15)


def P1(X):
    return X ^ (X << 15 & 0xffffffff | X >> 17) ^ (X << 23 & 0xffffffff | X >> 9)


def FF(j, X, Y, Z):
    if j <= 15:
        output = X ^ Y ^ Z
    else:
        output = (X & Y) | (Y & Z) | (Z & X)
    return output


def GG(j, X, Y, Z):
    if j <= 15:
        output = X ^ Y ^ Z
    else:
        output = (X & Y) | (Z & (X ^ (0xffffffff)))
    return output


def diedaiyasuo(plaintext, n):
    V = [0] * (n + 1)
    V[0] = 0x7380166f4914b2b9172442d7da8a0600a96f30bc163138aae38dee4db0fb0e4e
    W = [0] * 68
    WW = [0] * 64
    for i in range(n):
        m = (plaintext >> ((n - 1 - i) * 512)) & ((1 << 512) - 1)  # 将明文分为长度为512bit的组
        for j in range(16):
            W[j] = (m >> (32 * (15 - j))) & 0xffffffff
        for j in range(16, 68):
            W[j] = P1(W[j - 16] ^ W[j - 9] ^ ((W[j - 3] << 15) & 0xffffffff | (W[j - 3] >> 17))) ^ (
                    (W[j - 13] << 7) & 0xffffffff | (W[j - 13] >> 25)) ^ W[j - 6]
        for j in range(64):
            WW[j] = W[j] ^ W[j + 4]
        A = [0] * 8
        for j in range(8):
            A[j] = (V[i] >> (32 * (7 - j))) & 0xffffffff
        T = [0] * 64
        for j in range(16):
            T[j] = 0x79cc4519
        for j in range(16, 64):
            T[j] = 0x7a879d8a
        for j in range(64):
            ss = ((A[0] << 12) & 0xffffffff | (A[0] >> 20)) + A[4] + (
                    (T[j] << (j & 31)) & 0xffffffff | (T[j] >> (32 - (j & 31))))
            ss = ss & 0xffffffff
            SS1 = (ss << 7) & 0xffffffff | (ss >> 25)
            SS2 = SS1 ^ ((A[0] << 12) & 0xffffffff | A[0] >> 20)
            TT1 = (FF(j, A[0], A[1], A[2]) + A[3] + SS2 + WW[j]) & 0xffffffff
            TT2 = (GG(j, A[4], A[5], A[6]) + A[7] + SS1 + W[j]) & 0xffffffff
            A[3] = A[2]
            A[2] = (A[1] << 9) & 0xffffffff | (A[1] >> 23)
            A[1] = A[0]
            A[0] = TT1
            A[7] = A[6]
            A[6] = (A[5] << 19) & 0xffffffff | (A[5] >> 13)
            A[5] = A[4]
            A[4] = P0(TT2)
        V[i + 1] = ((A[0] << (32 * 7)) | (A[1] << (32 * 6)) | (A[2] << (32 * 5)) | (A[3] << (32 * 4)) | (
                A[4] << (32 * 3)) | (A[5] << (32 * 2)) | (A[6] << 32) | A[7]) ^ V[i]

    return V[n]


def sm3enc(plaintext, plainlen):
    plaintext = tianchong(plaintext, plainlen)
    n = (plainlen + 576) >> 9
    return diedaiyasuo(plaintext, n)


# rho算法：
# 实验目标为：对32bitsm3hash进行攻击
# 流程：生成一个32bit的随机数，进行sm3加密。然后取前32bit作为下一次加密的输入，以此类推
#     然后按照rho算法的思想，判断其中是否有环出现，如果找到i使得hash[i]==hash[2*i]，那么就向前寻找j使得hash[i-j+1]==hash[2*i-j+1],但是hash[i-j]!=hash[2*i-j]，则碰撞成功
# ps:由于库中的sm3函数输入输出的形式不统一，故本次代码使用了自己编写的sm3算法


plaintext = random.randint(0, 1 << 32)  # 随机生成一个明文
hashlist = [plaintext]
for i in range(0, 1 << 32):
    hash = sm3enc(hashlist[2 * i], 32) >> 224
    hashlist = hashlist + [hash]
    hash = sm3enc(hashlist[2 * i + 1], 32) >> 224
    hashlist = hashlist + [hash]
    if hashlist[i + 1] == hashlist[2 * i + 2]:
        for j in range(0, i):
            if hashlist[i - j] != hashlist[2 * i + 1 - j]:
                print('消息：', hex(hashlist[i - j]))
                print('和消息：', hex(hashlist[2 * i + 1 - j]))
                print('碰撞成功')
                exit(0)
